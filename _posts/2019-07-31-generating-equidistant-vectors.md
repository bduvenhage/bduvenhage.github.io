---
layout: post
title:  "Generating Equidistant Points on a Sphere"
date: 2019-07-31
published: true
comments: true
categories: [geometry]
tags: [geometry, computer graphics]
---

In this post I'll revive work I did during my PhD to generate 3D points that are equally spaced on the unit sphere. Such equidistant points are useful for many operations over the sphere as well as to properly tesselate it. The method is based on a spiral walk of the spherical surface in angular increments equal to the golden angle. The golden angle is related to the golden ratio.

<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>

Two quantities are in the golden ratio, $$\varphi$$, if their ratio is the same as the ratio of their sum to the larger of the two quantities. $$\frac{a}{b} = \frac{a+b}{a} := \varphi$$ which is approximately 1.6180339887... The golden angle $$\vartheta$$ is the angle subtended by the small arc $$b$$ which is approximately 2.3999632297... radians or 137.5077640500... degrees.

<img src="/assets/images/golden_angle.jpg" width="240" />

The ratios between consecutive Fibonacci numbers approach the golden ratio. Also, an alternative for expressing the Fibonacci sequence is $$F\left(n\right)=\frac{\varphi^{n} - (1-\varphi)^{n}}{\sqrt{5}}$$. #mindblown ðŸ¤¯. The spiral walk discussed here is therefore often referred to as a spherical Fibonacci lattice or a Fibonacci spiral sphere.

The method presented here I originally implemented for a paper on [Numerical Verification of Bidirectional Reflectance Distribution Functions for Physical Plausibility](https://dl.acm.org/citation.cfm?id=2513499). A pre-print of the paper is available from [ResearchGate](https://www.researchgate.net/publication/259885429_Numerical_Verification_of_Bidirectional_Reflectance_Distribution_Functions_for_Physical_Plausibility) and via my [Google Scholar page](https://scholar.google.com/citations?user=jqhH0o4AAAAJ). The paper also discusses an alternative method based on subdivision of a 20-sided regular icosahedron.

## The Fibonacci Spiral Disc
The Fibonacci spiral is a way of stepping around a circle to generate angular positions with limited repeated structure in the sequence. The step size is equal to the golden angle. Due to the properties of the golden angle, if one were to create a histogram of angles generated by this methods then the angle bins will always be approximately equally filled. 

Using [Vogal's method](https://www.sciencedirect.com/science/article/abs/pii/0025556479900804?via%3Dihub), one can combine this property with an increasing radius $$r$$ to distribute points on a 2D disc. Even distribution of points over different radii of the disc is ensured by having $$r = k\sqrt{i}$$ for $$i$$ the index of the point being generated and $$k$$ inversely proportional to the overall density of the points. Due to the relationship between the radius and the point's index, the disc's surface area correctly grows in proportion to the number of points.

Putting this together, $$P_i = (k\sqrt{i}, i\vartheta)$$ is the range and angle cylindrical polar coordinate of point $$i$$ for $$i > 0$$.

<img src="/assets/images/fibonacci_spiral_disc_10.jpg" width="320" />
<img src="/assets/images/fibonacci_spiral_disc_5.jpg" width="320" />

Shown above is a spiral disc with 500 points for $$k = 10.0$$ (left) and $$k = 5.0$$ (right). A characteristic of this method is that there seems to be a space in the centre for another point.

The C++ code to generate the points on the disc is:
{% highlight c++ %}
std::vector<Vec2> fibonacci_spiral_disc(const int num_points, const double k) {
    std::vector<Vec2> vectors;
    vectors.reserve(num_points);

    const double gr=(sqrt(5.0) + 1.0) / 2.0;  // golden ratio = 1.6180339887498948482
    const double ga=(2.0 - gr) * (2.0*M_PI);  // golden angle = 2.39996322972865332

    for (size_t i=1; i <= num_points; ++i) {
        const double r = sqrt(i) * k;
        const double theta = ga * i;

        const double x = cos(theta) * r;
        const double y = sin(theta) * r;

        vectors.emplace_back(x, y);
    }
    
    return vectors;
}
{% endhighlight %}

## The Fibonacci Spiral Sphere
One can use a similar spiral method to also distribute points on a sphere. To evenly distribute the points, proportionally more turns are allocated to larger circles on the sphere. If the spiral starts at a sphere's pole then the radius and circumference of the spiral at any point is proportional to $$\cos(lat)$$ for $$lat$$ in $$[-\frac{\pi}{2}, \frac{\pi}{2}]$$. The density of the turns of the spiral is therefore also proportional to $$\cos(lat)$$ and the continuous distribution function (CDF) of the turns proportional to $$\sin(lat)+1$$. 

Given the CDF, the point index $$i$$ of a latitude can be calculated with $$i = \frac{N+1}{2} (\sin(lat)+1)$$ for $$N$$ the total number of points required. Then taking the inverse gives, $$lat = \arcsin(i\frac{2}{N+1} - 1)$$.

Wrapping this up, $$P_i = (\arcsin(i\frac{2}{N+1} - 1), i\vartheta)$$, is the latitude & longitude spherical polar coordinate of point $$i$$ for $$i$$ in $$[1,N]$$. Notice that the longitude component of the coordinate is the same as for the disc, but the disc's radius component has been adapted to a latitude component for the sphere of $$N$$ points.

<img src="/assets/images/fibomesh.jpg" width="320" />
<img src="/assets/images/fibogeodual.jpg" width="320" />

Shown above is a tessellated Fibonacci spiral sphere with 162 points (on the left) and its geometric dual (on the right). The geometric dual shows the shapes of the spaces around each of the equidistant points. Note that the points are generated in latitude order. To tesselate the sphere one still needs to apply a Delaunay or similar triangulation algorithm.

The C++ code to generate the points on the sphere is:
{% highlight c++ %}
std::vector<Vec3> fibonacci_spiral_sphere(const int num_points) {
    std::vector<Vec3> vectors;
    vectors.reserve(num_points);
    
    const double gr=(sqrt(5.0) + 1.0) / 2.0;  // golden ratio = 1.6180339887498948482
    const double ga=(2.0 - gr) * (2.0*M_PI);  // golden angle = 2.39996322972865332

    for (size_t i=1; i <= num_points; ++i) {
        const double lat = asin(-1.0 + 2.0 * double(i) / (num_points+1));
        const double lon = ga * i;

        const double x = cos(lon)*cos(lat);
        const double y = sin(lon)*cos(lat);
        const double z = sin(lat);

        vectors.emplace_back(x, y, z);
    }
    
    return vectors;
}
{% endhighlight %}

## Summary
The Fibonacci lattice/spiral is a simple and efficient method for generating equidistant points on the unit sphere. The golden angle is approximately 2.400 radians or 137.5 degrees. Therefore, each turn of the spiral walk adds two or three points to the sphere. To tesselate the sphere one still needs to apply a Delaunay or similar triangulation algorithm.

Full [source](https://github.com/bduvenhage/Bits-O-Cpp/tree/master/geometry) for generating the equidistant points is available in my [Bits-O-Cpp](https://github.com/bduvenhage/Bits-O-Cpp) GitHub repo.
